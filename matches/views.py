import random
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.db import transaction
from django.contrib import messages
from .models import Match, GiftAssignment
from users.models import Participant
from gifts.models import WishListItem


@login_required
def matches_list(request):
    """Show the current user's Secret Santa match and assigned gifts."""
    try:
        participant = Participant.objects.get(user=request.user)
    except Participant.DoesNotExist:
        messages.error(
            request,
            'You need to be a participant to view matches. '
            'Join Secret Santa first!'
        )
        return render(
            request,
            "matches/matches_list.html",
            {'match': None, 'assigned_gifts': []}
        )

    # Get the match where this participant is the giver
    try:
        match = Match.objects.get(giver=participant)
        has_match = True
        # Get assigned gifts for this match
        assigned_gifts = GiftAssignment.objects.filter(
            match=match
        ).select_related('gift')
    except Match.DoesNotExist:
        match = None
        has_match = False
        assigned_gifts = []
        messages.info(
            request,
            'No match found yet. Matches will be generated by the admin.'
        )

    context = {
        "match": match,
        "has_match": has_match,
        "assigned_gifts": assigned_gifts,
    }

    return render(request, "matches/matches_list.html", context)


def generate_matches():
    """
    Randomly match each participant with another participant.
    Each person gives to a randomly assigned person (circular matching).
    Also randomly assigns gifts from receiver's wishlist to each giver.
    If receiver's wishlist is short, gifts are reused.

    Returns: (success: bool, message: str)
    """
    # Get all participants
    participants = list(Participant.objects.all())

    # Need at least 2 people
    if len(participants) < 2:
        return False, "Need at least 2 participants to create matches!"

    # Check if matches already exist
    if Match.objects.exists():
        return False, "Matches already exist! Clear them first."

    try:
        with transaction.atomic():
            # Shuffle participants randomly
            random.shuffle(participants)

            # Create circular random matches
            # Each person gives to the next person in the shuffled list
            # Last person gives to first person (ensures everyone is matched)
            matches_created = []
            for i in range(len(participants)):
                giver = participants[i]
                receiver = participants[(i + 1) % len(participants)]
                match = Match.objects.create(giver=giver, receiver=receiver)
                matches_created.append(match)

            # Assign gifts from receiver's wishlist to each giver
            gifts_assigned_count = 0
            for match in matches_created:
                receiver_gifts = list(
                    WishListItem.objects.filter(
                        participant=match.receiver
                    )
                )

                if receiver_gifts:
                    # Number of gifts to assign per match
                    # Assign up to 3, or reuse if needed
                    num_gifts_to_assign = min(3, len(receiver_gifts) * 2)

                    # Randomly select gifts, with replacement if needed
                    selected_gifts = random.choices(
                        receiver_gifts,
                        k=num_gifts_to_assign
                    )

                    # Create gift assignments (allow duplicates if list is short)
                    for gift in selected_gifts:
                        GiftAssignment.objects.create(
                            match=match,
                            gift=gift
                        )
                        gifts_assigned_count += 1

            count = len(participants)
            return True, (
                f"Successfully matched {count} participants and "
                f"assigned {gifts_assigned_count} gifts!"
            )

    except Exception as e:
        return False, f"Error: {str(e)}"
