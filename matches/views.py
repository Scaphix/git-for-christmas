import random
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.db import transaction
from django.contrib import messages
from .models import Match, GiftAssignment
from users.models import Participant
from gifts.models import WishListItem


@login_required
def matches_list(request):
    """Show the current user's Secret Santa match and assigned gifts."""
    try:
        participant = Participant.objects.get(user=request.user)
    except Participant.DoesNotExist:
        messages.error(
            request,
            'You need to be a participant to view matches. '
            'Join Secret Santa first!'
        )
        return render(
            request,
            "matches/matches_list.html",
            {'match': None, 'assigned_gifts': []}
        )

    # Get the match where this participant is the giver
    try:
        match = Match.objects.get(giver=participant)
        has_match = True
        # Get assigned gifts for this match (unique gifts only)
        # Get one assignment per unique gift (the first one)
        assigned_gifts = []
        seen_gift_ids = set()
        for assignment in (
            GiftAssignment.objects.filter(match=match)
            .select_related('gift')
            .order_by('assigned_at')
        ):
            if assignment.gift_id not in seen_gift_ids:
                assigned_gifts.append(assignment)
                seen_gift_ids.add(assignment.gift_id)
    except Match.DoesNotExist:
        match = None
        has_match = False
        assigned_gifts = []
        messages.info(
            request,
            'No match found yet. Matches will be generated by the admin.'
        )

    context = {
        "match": match,
        "has_match": has_match,
        "assigned_gifts": assigned_gifts,
    }

    return render(request, "matches/matches_list.html", context)


def generate_matches():
    """
    Randomly match each participant with another participant.
    Each person gives to a randomly assigned person (circular matching).
    Also randomly assigns gifts from receiver's wishlist to each giver.
    If receiver's wishlist is short, gifts are reused.

    Returns: (success: bool, message: str)
    """
    # Get all participants
    participants = list(Participant.objects.all())

    # Need at least 2 people
    if len(participants) < 2:
        return False, "Need at least 2 participants to create matches!"

    # Check if matches already exist
    if Match.objects.exists():
        return False, "Matches already exist! Clear them first."

    try:
        with transaction.atomic():
            # Shuffle participants randomly
            random.shuffle(participants)

            # Create circular random matches
            # Each person gives to the next person in the shuffled list
            # Last person gives to first person (ensures everyone is matched)
            matches_created = []
            for i in range(len(participants)):
                giver = participants[i]
                receiver = participants[(i + 1) % len(participants)]
                match = Match.objects.create(giver=giver, receiver=receiver)
                matches_created.append(match)

            # Assign gifts from receiver's wishlist to each giver
            gifts_assigned_count = 0
            matches_without_gifts = []
            for match in matches_created:
                receiver_gifts = list(
                    WishListItem.objects.filter(
                        participant=match.receiver
                    )
                )

                if receiver_gifts:
                    # Number of gifts to assign per match
                    # Assign up to 2, fewer if receiver has fewer
                    num_gifts_to_assign = min(2, len(receiver_gifts))

                    # Randomly select gifts, with replacement if needed
                    selected_gifts = random.choices(
                        receiver_gifts,
                        k=num_gifts_to_assign
                    )

                    # Create gift assignments
                    # (allow duplicates if list is short)
                    for gift in selected_gifts:
                        GiftAssignment.objects.create(
                            match=match,
                            gift=gift
                        )
                        gifts_assigned_count += 1
                else:
                    # Track matches where receiver has no wishlist items
                    matches_without_gifts.append(
                        match.receiver.user.username
                    )

            count = len(participants)
            message = (
                f"Successfully matched {count} participants and "
                f"assigned {gifts_assigned_count} gifts!"
            )
            if matches_without_gifts:
                message += (
                    f" Note: {len(matches_without_gifts)} receiver(s) have "
                    f"no wishlist items: {', '.join(matches_without_gifts)}"
                )

            return True, message

    except Exception as e:
        return False, f"Error: {str(e)}"


def assign_gifts_to_matches():
    """
    Randomly assign gifts from receiver's wishlist to existing matches.
    Assigns up to 2 gifts per match, fewer if receiver has fewer.

    Returns: (success: bool, message: str)
    """
    # Check if matches exist
    matches = Match.objects.all()
    if not matches.exists():
        return False, "No matches exist! Generate matches first."

    try:
        with transaction.atomic():
            # Clear existing gift assignments
            GiftAssignment.objects.all().delete()

            # Assign gifts from receiver's wishlist to each giver
            gifts_assigned_count = 0
            matches_without_gifts = []
            for match in matches:
                receiver_gifts = list(
                    WishListItem.objects.filter(
                        participant=match.receiver
                    )
                )

                if receiver_gifts:
                    # Randomly select gifts, with replacement if needed
                    selected_gifts = random.choice(receiver_gifts)

                    # Create gift assignments
                    # (allow duplicates if list is short)
                    GiftAssignment.objects.create(
                            match=match,
                            gift=selected_gifts
                        )
                    gifts_assigned_count += 1
                else:
                    matches_without_gifts.append(
                            match.receiver.user.username
                        )
            return True,
            f"Successfully assigned {gifts_assigned_count} gifts to "
            f"{matches.count()} match(es)!"

    except Exception as e:
        return False, f"Error: {str(e)}"


def clear_gift_assignments():
    """
    Clear all gift assignments.

    Returns: (success: bool, message: str)
    """
    try:
        count = GiftAssignment.objects.count()
        GiftAssignment.objects.all().delete()
        return True, f"Successfully cleared {count} gift assignment(s)!"
    except Exception as e:
        return False, f"Error: {str(e)}"
